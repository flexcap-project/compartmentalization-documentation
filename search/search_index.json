{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Software Compartmantalization: A Beginner's Guide","text":"<p>TODO entire doc</p> <ul> <li>In the sources write 1 sentence per line (makes things much cleaner for version control)</li> </ul> <p>TODO homepage</p> <ul> <li>1 paragraph summarizing what compartmentalization is and motivating it</li> <li>1 paragraph motivating the documentation and detailing what is the target audience</li> <li>A summary of the documentation's structure</li> <li>1 paragraph explaining that everyhting is open source, giving a link to the repo on GitHub and exaplaining that we welcome contributions</li> </ul> <p>TODO list of authors below</p> <ul> <li>add our affiliations</li> <li>add links</li> </ul> <p>Authors: John Alistair Kressel, Hugo Lefeuvre and Pierre Olivier</p>"},{"location":"chapters/01-what-is-compartmentalization/","title":"What is Compartmentalization?","text":"<p>Software compartmentaliaation is a software engineering practice where developers break down a program into groups of isolated and distrusting components, called compartments, each controlling only the resources they require to do their tasks. Software compartmentalization is an embodiment of the principle of least privilege: by ensuring that each part of the program only runs with the least set of privileges necessary to complete its job, we can reduce the damage caused by a bug or compromise. Think of a compartment like a box containing part of a program. If a software component is compromised in a compartmentalized program, for example through a zero-day bug, attackers will be restricted to the permissions and capabilities of the compromised component. To escalate privileges and compromise the rest of the system, attackers will need to find a way to escape from the compartment.</p> <p>TODO here</p> <ul> <li>Maybe remind explain that the concept of compartmentalization comes from (and provides analogous protection) various safety fields, e.g. ship design, fire protection.</li> <li>Give the usual example: a web server with a bit that is not fully trusted (e.g. http parser) and another bit that is security critical (e.g. crypto library): a typical attack leverages a vulnerability in the parser to access the crypto library. Explain how compartmentalization cna help.</li> </ul>"},{"location":"chapters/01-what-is-compartmentalization/#why-would-i-compartmentalize","title":"Why would I compartmentalize?","text":"<p>TODO here</p> <ul> <li>What we need here is a motivation about compartmentalization, not a list of trust models (that should come later)</li> <li>Summarize all the benefits (maybe link to the next chapter), insist on supply chain attacks and other vulnerabilities that are unknown or that do not even exist yet</li> <li>Software is getting more an more complex, these issues are becoming more concerning</li> </ul>"},{"location":"chapters/01-what-is-compartmentalization/#properties-enforced","title":"Properties Enforced","text":"<p>TODO</p> <ul> <li>CIA triad</li> </ul>"},{"location":"chapters/01-what-is-compartmentalization/#trust-models","title":"Trust Models","text":"<p>Broadly there are three main trust models:</p> <ol> <li> <p>Sandboxing: here part of a program is sandboxed, meaning that the rest of the system is protected from it. This means that the sandbox is untrusted and whatever resides within the sandbox is contained and prevented from causing damage. We may choose to sandbox untrusted components, third-party components, code handling untrusted input or anything which may be buggy.</p> </li> <li> <p>Safeboxing: here a part of a program is protected from the rest of the system. This is typically applied to sensitive data or components eg. crypto keys to protect them from malicious interference. In this trust model everything in a safebox is trusted. A safebox can access the untrusted portion of the system but the untrusted portion cannot access the safebox.</p> </li> <li> <p>Mutual Distrust: in this trust model, compartments distrust each other and compartmentalization is implemnted in such a way that compartments are protected from other compartments.</p> </li> </ol>"},{"location":"chapters/01-what-is-compartmentalization/#what-software-canshould-be-compartmentalized","title":"What Software Can/Should be Compartmentalized?","text":"<p>Compartmentalization can be applied to any piece of software, including but not limited to: applications, kernels, operating systems, hypervisors, firmware and language runtimes. </p> <p>!!! \"TODO here\"     - Give concrete example of existing compartmentalized software running in production     - Software that benefit from compartmentalization: when you cannot see your app anymore as a single unit of trust (most software would fit that descirption these days as they e.g. integrate source code coming from various sources of variable trustworthiness)     - Ack that it's not widespread, point out the regain of popularity due to recent technology (isolation mechanisms, compilers techniques) improvements + growing cyber security concerns     - Present designing for compartmentalization vs. retrofitting it</p>"},{"location":"chapters/02-why-compartmentalization/","title":"Why Compartmentalization?","text":"<p>Compartmentalization is an invaluable technique for software developers. It is useful for the following reasons:</p> <ol> <li> <p>Compartmentalizing to contain memory-safety issues. Containing memory safety issues is a popular use-case of software compartmentalization: software parts which are more likely to feature memory-safety bugs (e.g., performing error-prone tasks such as parsers), or components where bugs are most likely to be exploited (e.g those facing the network) are isolated into an unprivileged compartment (sandbox) to limit the impact of future, unknown bugs. By virtue of memory isolation, memory safety issues affecting these components are then contained within their originating compartment.</p> </li> <li> <p>Compartmentalizing to protect against untrusted dependencies. Another application of software compartmentalization is protecting a program against untrusted dependencies. Such cases take place when either the supply chain or the dependency itself are distrusted or considered compromised. In a monolithic program, the impact of relying on an untrusted dependency corresponds to granting attackers with permissions to execute arbitrary code, regardless of whether or not the dependency is written in a safe language. Here too, sandboxing can help mitigate the impact of a malicious or compromised dependency.</p> </li> <li> <p>Compartmentalizing to protect critical data and code. Programs often embed data which demands special protection. Such data includes program secrets (e.g., cryptographic keys, passwords and credentials, more broadly authentication data), as well as data critical to enforcing security mechanisms (e.g., shadow stacks, CPI and CPS regions, randomisation information, or page tables in the kernel). Similarly, programs often embed code sections which require elevated privileges, for instance performing a system call such as setuid or setgid to change user IDs, known to cause serious vulnerabilities when subverted. In all cases, compartmentalization can be employed to prevent illegitimate accesses to critical data or code. This type of compartmentalization differs from 1 and 2 in that it is not directed at the part of the program which is distrusted, but at the one which is trusted. We refer to this model as safebox, by opposition to the sandbox model (1-2). An example of this use-case is isolating OpenSSL to protect cryptographic keys.</p> </li> <li> <p>Compartmentalizing to make software more reliable. If one component of a monolithic program crashes, becomes unresponsive, or misbehaves, so does the entire program. Software compartmentalization increase program reliability: by introducing boundaries between components, individual program parts can be restarted without impacting the whole, provided program state is appropriately segregated.</p> </li> </ol>"},{"location":"chapters/03-compartmentalization-getting-started/","title":"Getting Started","text":"<p>For the remainder of the tutorial we will describe the steps needed when considering and implementing compartmentalization by considering a real application.</p>"},{"location":"chapters/04-policy-definition/","title":"Defining a Policy","text":""},{"location":"chapters/04-policy-definition/#what-is-a-compartmentalization-policy","title":"What is a compartmentalization policy?","text":"<p>Compartmentalization policy describes the compartmentalization policies and properties which should be enforced. This directly impacts the requirements and impacts of compartmentalization such as the performance impact.</p> <p>Policy definition can be broken down into two tasks:</p> <p>1) Deciding which parts of a program to compartmentalize, 2) Deciding which permissions to enforce on each compartment.</p>"},{"location":"chapters/04-policy-definition/#which-parts-of-a-program","title":"Which parts of a program","text":"<p>To begin, it is useful to consider the goals you wish to achieve through compartmentalization. Do you wish to isolate pontentially buggy software components or protect against third party dependencies? Sandboxing those dependencies may be the way to go. Protecting sensitive data? Safeboxing those components may be sensible.</p>"},{"location":"chapters/04-policy-definition/#code-or-data-centric","title":"Code or data centric?","text":""},{"location":"chapters/04-policy-definition/#permissions","title":"Permissions","text":""},{"location":"chapters/05-policy-enforcement/","title":"Enforcing the Policy","text":""},{"location":"chapters/05-policy-enforcement/#available-mechanisms","title":"Available mechanisms","text":""},{"location":"chapters/05-policy-enforcement/#choosing-the-right-mechanims","title":"Choosing the right mechanims","text":""},{"location":"chapters/06-interfaces/","title":"Securing Interfaces","text":""},{"location":"chapters/07-practical-application/","title":"Tutorial","text":""}]}